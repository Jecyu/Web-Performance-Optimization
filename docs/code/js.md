  - 延迟（执行、加载）
  - 按需（加载）
  - 缓存（资源）
  - 预备（提前执行、加载）

### JS 为什么说对象字面量赋值比 new Object() 高效？

`{}` 是字面量，可以立即求值，而 `new Object()` 本质上是方法（只不过这个方法是内置的），既然是方法调用，就涉及到在 `proto` 链中遍历该方法，当找到该方法后，又会生成方法调用必须的堆栈信息，方法调用结束后，还要释放该堆栈。

单例模式、缓存

- [JS 为什么说对象字面量赋值比 new Object() 高效？](https://www.jianshu.com/p/2abed1d35e38)

### 原型链上的优化

公共的方法放在 prototype 上，而不是每次都复制到 this 实例里。

### 缓存

#### 将对象的属性值保存为局部变量

对象成员嵌套越深，读取速度也就越慢。所以好的经验法则是：如果在函数中需要多次读取一个对象属性，最佳做法是将该属性值保存在局部变量中，避免多次查找带来的性能开销。

## JS垃圾回收机制

“可达性”

3D图形引擎的性能主要由其判断一个场景中的可见部分的能力决定的。

## 递归调用（尾递归优化）