<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器之 HTTP 缓存机制解读 | 微谈 Web 前端性能优化</title>
    <meta name="description" content="Analysis vue.js deeply">
    <link rel="icon" href="/Web-Performance-Optimization/logo.png">
  <link rel="manifest" href="/Web-Performance-Optimization/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/Web-Performance-Optimization/icons/apple-touch-icon-152x152.png">
  <link rel="mask-icon" href="/Web-Performance-Optimization/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/Web-Performance-Optimization/assets/css/0.styles.841911cb.css" as="style"><link rel="preload" href="/Web-Performance-Optimization/assets/js/app.7cae2d68.js" as="script"><link rel="preload" href="/Web-Performance-Optimization/assets/js/2.72369abb.js" as="script"><link rel="preload" href="/Web-Performance-Optimization/assets/js/4.df7b7976.js" as="script"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/10.a5dacc7d.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/11.02148d24.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/12.acd7b156.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/13.837abe37.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/14.0f6e7494.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/15.b7cfaf21.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/16.18e998c2.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/17.f2b51082.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/18.fd8bf8b2.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/19.ac77f635.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/20.f3fb8221.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/21.b6c75ca9.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/22.5b60da5a.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/23.e8cdc260.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/24.18b6675d.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/25.81f7219b.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/26.cf52eab7.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/27.892d8e46.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/28.36470c5c.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/29.94a5d762.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/3.c2cb7e60.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/30.01fe9788.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/31.21d6cc04.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/32.b9a9aea8.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/33.d303235b.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/34.0696d0a6.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/35.523a3368.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/36.3ec948c0.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/5.d4962001.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/6.66c2d2c9.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/7.ffbcbdd2.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/8.7a41af06.js"><link rel="prefetch" href="/Web-Performance-Optimization/assets/js/9.a97348ef.js">
    <link rel="stylesheet" href="/Web-Performance-Optimization/assets/css/0.styles.841911cb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Web-Performance-Optimization/" class="home-link router-link-active"><!----> <span class="site-name">微谈 Web 前端性能优化</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/Jecyu/Web-Performance-Optimization/tree/master/examples" target="_blank" rel="noopener noreferrer" class="nav-link external">
  配套例子
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/Jecyu/Web-Performance-Optimization" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/Jecyu/Web-Performance-Optimization/tree/master/examples" target="_blank" rel="noopener noreferrer" class="nav-link external">
  配套例子
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/Jecyu/Web-Performance-Optimization" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>开篇</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Web-Performance-Optimization/concept/" class="sidebar-link">Web 性能优化基础认知</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工具篇</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Web-Performance-Optimization/tool-monitor/" class="sidebar-link">介绍</a></li><li><a href="/Web-Performance-Optimization/tool-monitor/indicator.html" class="sidebar-link">解读 Web 性能体验和质量指标</a></li><li><a href="/Web-Performance-Optimization/tool-monitor/chromeDev.html" class="sidebar-link">唯快不破，Chrome DevTools 性能优化手把手教学</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络篇</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Web-Performance-Optimization/network/" class="sidebar-link">介绍</a></li><li><a href="/Web-Performance-Optimization/network/request.html" class="sidebar-link">资源请求</a></li><li><a href="/Web-Performance-Optimization/network/download.html" class="sidebar-link">资源下载</a></li><li><a href="/Web-Performance-Optimization/network/render.html" class="sidebar-link">资源渲染</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>缓存篇</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Web-Performance-Optimization/cache/" class="sidebar-link">介绍</a></li><li><a href="/Web-Performance-Optimization/cache/browser-cache.html" class="active sidebar-link">浏览器之 HTTP 缓存机制解读</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#http-缓存机制探秘" class="sidebar-link">HTTP 缓存机制探秘</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#http-标头信息如何指示浏览器进行资源缓存" class="sidebar-link">HTTP 标头信息如何指示浏览器进行资源缓存</a></li><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#用户行为对浏览器的缓存策略的影响" class="sidebar-link">用户行为对浏览器的缓存策略的影响</a></li></ul></li><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#强缓存" class="sidebar-link">强缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#expires" class="sidebar-link">Expires</a></li><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#cache-control" class="sidebar-link">Cache-Control</a></li><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#其他补充：pragma-与-vary" class="sidebar-link">其他补充：Pragma 与 Vary</a></li></ul></li><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#协商缓存" class="sidebar-link">协商缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#last-modified-if-modified-since" class="sidebar-link">Last-Modified/If-Modified-Since</a></li><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#etag-if-modified-since" class="sidebar-link">Etag/If-Modified-Since</a></li></ul></li><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#如何废弃和更新缓存的资源" class="sidebar-link">如何废弃和更新缓存的资源</a></li><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#项目实战：进行资源更新时，为什么一定要手动清除缓存" class="sidebar-link">项目实战：进行资源更新时，为什么一定要手动清除缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#分析现有的缓存策略，进行资源的更新与验证。" class="sidebar-link">分析现有的缓存策略，进行资源的更新与验证。</a></li><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#缓存失效复现解决排查" class="sidebar-link">缓存失效复现解决排查</a></li><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#服务器如何进行配置以符合最佳实践原则" class="sidebar-link">服务器如何进行配置以符合最佳实践原则</a></li></ul></li><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/Web-Performance-Optimization/cache/browser-cache.html#参考资料" class="sidebar-link">参考资料</a></li></ul></li><li><a href="/Web-Performance-Optimization/cache/browser-localStorage.html" class="sidebar-link">浏览器之本地存储——Cookie、Web Storage、IndexedDB</a></li><li><a href="/Web-Performance-Optimization/cache/webapp.html" class="sidebar-link">Web 运行时缓存</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>渲染篇</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Web-Performance-Optimization/browser/" class="sidebar-link">浏览器背后的运行机制</a></li><li><a href="/Web-Performance-Optimization/browser/render.html" class="sidebar-link">浏览器渲染过程</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>应用篇</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Web-Performance-Optimization/action/bigData.html" class="sidebar-link">大数据量的渲染优化</a></li><li><a href="/Web-Performance-Optimization/action/code.html" class="sidebar-link">代码层面的优化</a></li><li><a href="/Web-Performance-Optimization/action/chart.html" class="sidebar-link">图表的性能优化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>参考资料</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Web-Performance-Optimization/reference/" class="sidebar-link">Web 性能优化资源合集（持续更新）</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器之-http-缓存机制解读"><a href="#浏览器之-http-缓存机制解读" class="header-anchor">#</a> 浏览器之 HTTP 缓存机制解读</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <blockquote><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。</p></blockquote> <p>你知道浏览器缓存是怎么回事吗？它可以带来哪些性能的收益？在 HTTP 请求流程中，为什么很多站点第二次打开速度会很快？缓存可以减少网络 IO 消耗，提高访问的速度。<code>浏览器缓存</code>是一种操作简单、效果显著的前端性能优化手段。</p> <p>打开 chrome network 面板，并取消禁用勾选 「Disable cache」，然后输入 www.taobao.com，首次进行资源请求并下载完成后，浏览器会对该资源进行缓存，以便第二次请求相同资源时提升响应的速度。</p> <p>现在我们刷新页面，发起第二次首页请求。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-18-18-09-44.3eb5cc78.png" alt=""></p> <p>从截图中可以看到，可以看到形如 “200 from xxx” 这样的描述——对应的资源，这些资源就是我们通过缓存获取到的。浏览器会根据资源的 HTTP 请求头和响应头等一些信息，对资源进行下载后，会把资源缓存到以下 4 种位置：</p> <ul><li><strong>内存缓存（Memory Cache）</strong>
内存缓存具有两个特点，分别是快速读取和时效性。浏览器自行判断什么进行写入，不受开发者控制。
<ul><li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li> <li>时效性：一旦该进程关闭，则该进程的内存则会清空。关闭 tab 页面后则失效，或者页面占用内存过多，排在前面的缓存先失效</li></ul></li> <li><strong>磁盘缓存（Disk Cache）</strong>
硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行 I/O 操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。硬盘中的缓存，持久存储，允许跨会话或跨站点。</li> <li><strong>Service Worker Cache（https）</strong> <ul><li>开发者进行人为存储的永久性存储，用于离线缓存的处理，可以在 Application -&gt; Cache Storage 查看。</li></ul></li> <li><strong>Push Cache（http2）</strong> <ul><li>Push Cache 是 HTTP2 在 sever push 阶段存在的缓存。</li></ul></li></ul> <p>在浏览器中，大部分情况下浏览器会在 js 和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)</p> <p>浏览器获取缓存的顺序为 Service Worker Cache、Memory Cache、Disk Cache、（至于 Push Cache 属于 HTTP2 待验证）。</p> <p>除了以上的缓存位置外，浏览器还提供一些本地存储方案，包括 <strong>Cookie</strong>、<strong>IndexedDB</strong> 和 <strong>LocalStorage</strong> 等，这些将在另外一篇文章中：<a href="/Web-Performance-Optimization/cache/browser-localStorage.html">浏览器之本地存储—Cookie、Web Storage、IndexedDB</a> 讲述 。</p> <p>本章主要讲述常用的 HTTP 的缓存机制，主要讲解如何通过 <strong>HTTP 请求头与响应头</strong>来控制资源的缓存与读取。</p> <p><strong>目标读者</strong>：希望了解浏览器加载的资源什么时候被缓存，什么时候资源缓存又失效。</p> <p><strong>文章大纲</strong>：</p> <ul><li>HTTP 缓存机制探秘</li> <li>强缓存详解</li> <li>协商缓存详解</li> <li>如何废弃和更新缓存的资源</li> <li>项目实战：进行资源更新时，为什么一定要手动清除缓存</li></ul> <p><strong>阅读时长</strong>：25 min</p> <p><strong>浏览器版本</strong>：Google Chrome 版本 85.0.4183.121（正式版本）（64 位），使用“隐身模式”不会让计算机上留下您访问网站的任何痕迹，包括缓存文件、Cookie、历史记录、下载记录等等，以及不受插件的影响。对于缓存而言。</p> <h2 id="http-缓存机制探秘"><a href="#http-缓存机制探秘" class="header-anchor">#</a> HTTP 缓存机制探秘</h2> <p>在具体了解 HTTP 缓存之前，先来明确几个术语：</p> <ul><li><strong>缓存命中率</strong>：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。</li> <li><strong>过期内容</strong>：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求，必须重新向<strong>源服务器</strong>请求新的内容或者验证缓存的内容是否仍然有效。</li> <li><strong>验证</strong>：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。</li> <li><strong>失效</strong>：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。</li></ul> <p>接下来，我们将提出几个问题，希望你看完本部分后，能够找到答案：</p> <ol><li>浏览器什么时候写缓存？</li> <li>浏览器什么时候读缓存？从哪里开始读？</li> <li>浏览器的缓存什么时候会失效，如何更新缓存？</li></ol> <h3 id="http-标头信息如何指示浏览器进行资源缓存"><a href="#http-标头信息如何指示浏览器进行资源缓存" class="header-anchor">#</a> HTTP 标头信息如何指示浏览器进行资源缓存</h3> <p>每个浏览器都自带了 HTTP 缓存实现功能。你只需要确保每个服务器响应都提供正确的 HTTP 标头指令、以指示浏览器<strong>何时缓存</strong>响应以及<strong>缓存多久</strong>。</p> <p>当服务器返回响应时，还会发出一组 HTTP 标头，用于描述响应的内容类型、长度、缓存指令、验证令牌等。比如，在下图的交互中，服务器返回一个 1024 字节的响应，指示客户端将其缓存最多 120 秒，并提供一个验证令牌（“x234dff”），可在响应过期后用来检查资源是否被修改。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-18-16-59-27.5191954d.png" alt=""></p> <p>当 Web 缓存发现请求的资源已经被存储，它就会<strong>拦截请求</strong>，返回该资源的副本，而不会去<strong>源服务器</strong>重新下载。接下来以一个简单的例子来说明 HTTP 缓存策略的出现：</p> <p>比如开发一个简单的页面，这个页面只有 index.html 页面和它的样式文件 a.css。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-19-16-03-12.b2379c3d.png" alt=""></p> <p>开发完成后放到服务器上，并进行访问，查看网络请求如下。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-19-16-13-54.4c8cfa03.png" alt=""></p> <p>如果每次都要请求 a.css，将会很影响加载性能，每次首屏加载时间都很长，我们希望能如下图这样：</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-19-16-16-05.fb109e92.png" alt=""></p> <p>可以看到 a.css 是<strong>304 条件请求</strong>，让浏览器拦截请求并使用本地缓存，这个也叫做<strong>协商缓存</strong>，告诉浏览器使用本地缓存前会先跟服务器确认，如果没变化就使用本地缓存，服务器只返回一个空的响应体，从而<strong>减少了响应体积</strong>来提升性能。</p> <p>能不能不再请求服务器，强制浏览器使用本地缓存呢，可以通过「Cache-Control/Expires」实现，这也叫做<strong>强缓存</strong>，从<strong>减少请求次数</strong>层面提升性能。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-19-16-34-59.a6a63904.png" alt=""></p> <p>HTTP 头信息控制缓存分为两种：<strong>强制缓存和协商缓存</strong>。强缓存如果命中，就不需要和服务器端发生交互，而协商缓存不管是否命中都要和服务器发生交互，<strong>强制缓存的优先级高于协商缓存</strong>。</p> <p>在浏览器已有缓存的情况下，让我们看看具体的匹配流程：</p> <p><img src="/Web-Performance-Optimization/assets/img/http-cache.drawio.3aaa076c.svg" alt=""></p> <p>以上就是浏览器的强缓存和协商缓存两种机制流程图，接下来我们看看用户行为对浏览器的缓存策略的影响。</p> <h3 id="用户行为对浏览器的缓存策略的影响"><a href="#用户行为对浏览器的缓存策略的影响" class="header-anchor">#</a> 用户行为对浏览器的缓存策略的影响</h3> <p>常见情况下，资源的缓存策略就是按照上一个小节的匹配流程顺序，强缓存 -&gt; 协商缓存 -&gt; 重新获取。但是，缓存策略是与用户的操作相关的，平时在浏览网页时我们常常会用到刷新，因此有必要提前了解刷新做了哪些操作，这样在了解强缓存和协商缓存时知道刷新的影响。</p> <p>具体用户操作如下图所示：</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-20-21-32-46.0e6b4033.png" alt=""></p> <p>在没有禁用 「Disable Cache」的情况下：</p> <ol><li>F5（command + r） 刷新，则在请求头添加 <code>Cache-Control: max-age=0</code>（html 资源符合，其他资源看具体情况），过期时间为 0，不会走强缓存。</li> <li>在同一个 tag 页面下，通过地址栏回车（再次访问），效果跟直接用 F5 刷新一样。</li> <li>强制刷新（crtl + f5 或 command + shift + r），会在请求头添加 <code>Cache-Control: no-cache</code>，每次都需要服务器评估是否有效。</li></ol> <p><img src="/Web-Performance-Optimization/assets/img/2020-11-13-09-20-40.cf11b70b.png" alt=""></p> <p>以上的东西你不必背下来，忘记的时候回到这里看看就行。好了，相信你已经迫不及待想要具体了解强缓存和协商缓存。</p> <h2 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h2> <p>强缓存可以理解为无须验证的缓存策略，不会再与服务端发生通信。可以造成强制缓存的字段是 <strong>Expires/Cache-Control</strong>，这些指令控制浏览器和其他中间缓存如何缓存各个响应以及缓存多久。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-19-23-21-27.6868950f.png" alt=""></p> <p>在<strong>没有禁用缓存</strong>并且<strong>没有超过有效时间</strong>的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取，返回的 HTTP 状态码为 200（如下图）。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-20-00-36-12.30a3dbd4.png" alt=""></p> <h3 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h3> <p>Expires 指缓存过期的时间，超过了这个时间点就代表资源过期。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-20-00-48-33.4d407246.png" alt=""></p> <p>假如服务器中有一个简单的网页，包括以下资源文件：</p> <ul><li>index.html</li> <li>logo.png</li> <li>style.css</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype">&lt;!DOCTYPE html&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>width=device-width, initial-scale=1.0<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>style.css<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>style.css<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Hello, Jecyu.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>./logo.png<span class="token punctuation">&quot;</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>./logo.png<span class="token punctuation">&quot;</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol><li><p>不设置设置服务器强制缓存头的情况下，首次访问网站首页，netwokr 表格图如下：（注意：对于同一页面同时请求重复的资源，浏览器不会再发起该请求）
<img src="/Web-Performance-Optimization/assets/img/2020-10-20-22-24-05.a0546391.png" alt=""></p> <p><img src="/Web-Performance-Optimization/assets/img/2020-11-13-10-21-02.5950b7ba.png" alt=""></p></li> <li><p>由于上一次请求没有任何响应缓存头设置，这个时候关闭 Tab 页面，然后再次访问页面，可以看到资源仍然从源服务器中获取。
<img src="/Web-Performance-Optimization/assets/img/2020-10-20-22-24-05.a0546391.png" alt=""></p></li> <li><p>现在给服务器响应头添加 Expires 设置，并重复 1、2 两个步骤。再次访问时，可以看到资源从 disk cache 获取。
<img src="/Web-Performance-Optimization/assets/img/2020-10-20-22-16-37.afe56f42.png" alt=""> <img src="/Web-Performance-Optimization/assets/img/2020-11-15-23-18-27.91cfb2ba.png" alt=""></p></li> <li><p>如果你在第 2 个步骤不是关闭当前 tab 页面，而是按 F5（Command + R） 刷新页面，请求 html 资源的请求头自动携带了 <code>max-age: 0</code>， 会先跟服务器通信验证，由于不存在协商缓存头。而其他资源 css、图片资源仍然从 memory cache 中获取。
<img src="/Web-Performance-Optimization/assets/img/2020-10-20-22-27-35.6213c7d9.png" alt=""></p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-20-22-26-26.bf32bbb5.png" alt=""></p> <p>如果你按 Crtl + F5 (或 Command + Shift + R)刷新的话，则所有的资源都会添加 <code>Cache-Control: no-cache</code> 请求头，因为没有设置协商缓存，因此所有资源都重新从源服务器获取。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-11-13-10-32-11.8db8285c.png" alt=""></p></li></ol> <p><strong>完整测试例子</strong>：<a href="https://github.com/Jecyu/Web-Performance-Optimization/tree/master/examples/cache/http/demo01/server.js" target="_blank" rel="noopener noreferrer">example/cache/http/demo01<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>现在我们给 Expires 一个特写：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Expires: Fri, <span class="token number">13</span> Nov <span class="token number">2020</span> 02:25:55 GMT
</code></pre></div><p><code>Expires</code> 其实是一个时间戳，这里只不过是格式化的显示。在我们再次向服务器请求相同的资源时，浏览器就会先对比本地时间和 <code>Expires</code> 的时间戳，如果本地时间小于 <code>Expires</code> 设定的过期时间，那么就直接去缓存中取这个资源。</p> <p>由于时间戳是服务器来定义的，而本地时间的取值却来自客户端，因此 <code>Expires</code> 的工作机制对客户端时间与服务器时间之间的一致性提出了极高的要求。如果服务器与客户端存在误差（时差、用户修改），将会导致意外的结果，那么 <code>Expires</code> 将无法达到我们的预期。</p> <h3 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> Cache-Control</h3> <p>Expires 允许我们通过<strong>绝对的时间戳</strong>来控制缓存的过期时间，这个设置不准确，因此 HTTP 1.1 新增了 <code>Cache-Control</code> 字段来解决 Expires 的问题。</p> <p>在 <code>Cache-Control</code> 中的 <code>max-age</code> 字段允许我们设定<strong>相对的时间长度</strong>来达到同样的目的。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-20-01-16-01.4c2e53ea.png" alt=""></p> <p>这里仍然使用 Expire 里提到的例子，主要证明 Cache-Control 的优先级更高：</p> <ol><li><p>不设置设置服务器强制缓存头的情况下，首次访问网站首页，Network 表格图如下：（注意：对于同一页面同时请求重复的资源，浏览器不会再发起该请求）
<img src="/Web-Performance-Optimization/assets/img/2020-10-20-22-24-05.a0546391.png" alt=""></p></li> <li><p>服务器开启 <code>Cache-Control</code> 缓存设置，进入页面后，关闭 tag 页面，重新打开，可以看到资源从 disk cache 获取。
<img src="/Web-Performance-Optimization/assets/img/2020-10-20-22-16-37.afe56f42.png" alt=""></p></li> <li><p>前面的行为跟单独设置 <code>Expire</code> 是一致的，现在给 <code>Expire</code> 设置一个较短的过期时间 10 秒。
<img src="/Web-Performance-Optimization/assets/img/2020-10-20-22-55-45.6dafa300.png" alt=""></p></li> <li><p>然后同时开启 <code>Cache-Control</code> 的 <code>max-age</code>（设置稍长点的时间段比如 2min），经过 10 秒后，关闭 tag 页面，重新打开，还是可以看到资源从 disk cache 获取，证明 Cache-Control 的优先级更高。
<img src="/Web-Performance-Optimization/assets/img/2020-10-20-22-51-17.1fbcf6a6.png" alt=""></p></li></ol> <p><strong>完整测试例子</strong>：<a href="https://github.com/Jecyu/Web-Performance-Optimization/tree/master/examples/http/demo02/server.js" target="_blank" rel="noopener noreferrer">examples/cache/http/demo02<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>我们给 Cache-Control 一个特写：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Cache-Control: max-age<span class="token operator">=</span><span class="token number">120</span>
</code></pre></div><p>在 Cache-Control 中，我们通过 <code>max-age</code> 来控制资源的有效期。<code>max-age</code> 不是一个时间戳，而是一个<code>时间段</code>。<code>max-age=120</code> 意味着该资源在 120 秒以内都是有效的，完美地规避了时间戳带来的潜在问题。</p> <p><u>Cache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。</u></p> <p>Cache-Control 除了 max-age，还有以下用法：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>Cache-Control: max-age<span class="token operator">=</span><span class="token number">120</span>, s-maxage<span class="token operator">=</span><span class="token number">31536000</span>
</code></pre></div><p>Web 标准中规定 max-age 的值最大不超过一年，所以设成 max-age=31536000。对于过期的内容，缓存区会将一段时间没有使用的文件删除掉。</p> <p><code>s-maxage</code> 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向<strong>代理服务器</strong>请求其缓存内容。</p> <p><code>s-maxage</code> 仅在<strong>代理服务器</strong>中生效，并只对 <code>public</code> 缓存有效，客户端我们只考虑 max-age。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-06-14-12-54-31-browser-cache-02.014d76ae.png" alt=""></p> <h4 id="public-与-private"><a href="#public-与-private" class="header-anchor">#</a> public 与 private</h4> <p><code>public</code> 与 <code>private</code> 是针对资源<strong>是否能够被代理服务器缓存</strong>而存在的一组对立概念。</p> <p>如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。<strong>private 为默认值</strong>。</p> <p>大多数情况下，“public”不是必须的，因为明确的缓存信息（例如“max-age”）已表示响应是可以缓存的，这样即使只设置 s-maxage，CDN 也可以缓存这个资源。</p> <h4 id="must-revalidate"><a href="#must-revalidate" class="header-anchor">#</a> must-revalidate</h4> <p>如果你配置了 max-age 信息，当缓存资源仍然新鲜（小于 max-age）时使用缓存，否则需要对资源进行验证。所以 must-revalidate 可以和 max-age 组合使用 <code>Cache-Control: must-revalidate, max-age=60</code></p> <p>对于验证资源是否还有效，还需要设置协商缓存来辅助。</p> <h4 id="no-store-和-no-cache"><a href="#no-store-和-no-cache" class="header-anchor">#</a> no-store 和 no-cache</h4> <p><code>no-store</code> 直接禁止浏览器以及所有中间缓存存储任何版本的返回响应。例如，包含个人隐私数据或银行数据的响应。每次用户请求该资产时，都会向服务器发送请求，并下载完整的响应。</p> <p><code>no-cache</code> 表示必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续同一网址的请求。因此，<u>如果存在合适的验证令牌（ETag），no-cache 会发起往返通信来验证缓存的响应，但如果资源未发生变化，则可避免下载。</u></p> <p>这里使用 Expire 里提到的例子，只是服务端配置不同，来说明 Cache-Control 的一些特性：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// server.js</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>
  express<span class="token punctuation">.</span><span class="token function">static</span><span class="token punctuation">(</span><span class="token string">&quot;public&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    etag<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 关闭 Etag 协商缓存</span>
    lastModified<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 关闭 lastModifed 协商缓存</span>
    cacheControl<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 关闭默认设置，在下面默认处理</span>
    <span class="token function-variable function">setHeaders</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span> path</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Cache-Control&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;no-cahce, max-age=60&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// res.setHeader(&quot;Cache-Control&quot;, &quot;no-store, max-age=60&quot;);</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol><li><p>设置响应头 no-cache 和 max-age 的情况下，初次访问页面时：
<img src="/Web-Performance-Optimization/assets/img/2020-10-20-23-30-41.648ea365.png" alt=""></p></li> <li><p>关闭页面或另打开一个 tag 页面，再次访问，no-cache 会获得如下的判断：
<img src="/Web-Performance-Optimization/assets/img/2020-11-14-14-46-30.427b1c62.png" alt=""></p></li> <li><p>现在设置 no-store 和 max-age ，并重复步骤 1 和步骤 2，发现再次请求相同的资源，无论 max-age 是否过期，都会重新请求服务器。</p></li></ol> <p><strong>完整测试例子</strong>：<a href="https://github.com/Jecyu/Web-Performance-Optimization/tree/master/examples/cache/http/demo03/server.js" target="_blank" rel="noopener noreferrer">examples/cache/http/demo03<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="其他补充：pragma-与-vary"><a href="#其他补充：pragma-与-vary" class="header-anchor">#</a> 其他补充：Pragma 与 Vary</h3> <h4 id="pragma-头"><a href="#pragma-头" class="header-anchor">#</a> Pragma 头</h4> <p><code>Pragma</code> 是 HTTP/1.0 标准中定义的一个 header 属性，请求中包含 <code>Pragma</code> 的效果跟在头信息中定义 <code>Cache-Control: no-cache</code> 相同，但是 HTTP 的响应头没有明确定义这个属性，所以它不能拿来完全替代 HTTP/1.1 中定义的 <code>Cache-control</code> 头。通常定义 <code>Pragma</code> 以向后兼容基于 HTTP/1.0 的客户端。</p> <h4 id="vary-响应"><a href="#vary-响应" class="header-anchor">#</a> Vary 响应</h4> <p>HTTP 响应头决定了对于后续的请求头，如何判断是请求一个新的资源还是使用缓存的文件。</p> <p>当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的 <code>Vary</code> 都匹配，才能使用缓存的响应。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-11-15-21-25-49.e097ef71.png" alt=""></p> <h2 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h2> <p>协商缓存依赖于服务端与浏览端之间的通信。</p> <p>协商缓存机制下，<u>浏览器需要向服务器去询问缓存的相关信息，</u>进而判断是<code>重新发起请求下载完整的响应</code>，还是从<code>本地获取缓存的资源</code>。</p> <p>如果服务端提示缓存资源未改动（Not Modified），请求会被浏览器缓存处理，<strong>这种情况下网络请求对应的状态码是 304。</strong>，而「200 OK（from cache）」是浏览器没有跟服务器确认，直接用了浏览器缓存。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-19-23-34-28.53863b8f.png" alt=""></p> <p>可以看到上图中的 <code>ETag</code> 的值是服务器生成并返回的随机令牌，通常是文件内容的哈希值或某个其他指纹。客户端不需要了解指纹是如何生成的，只需在下一次请求时将其 <code>If-None-Match</code> 的值，发送给服务器进行验证。</p> <p>协商缓存有两对值，分别是</p> <ul><li><code>Etag/If-Modified-Since</code></li> <li><code>Last-Modified/If-Modified-Since</code></li></ul> <h3 id="last-modified-if-modified-since"><a href="#last-modified-if-modified-since" class="header-anchor">#</a> Last-Modified/If-Modified-Since</h3> <p><code>Last-Modified</code> 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Last-Modified: Fri, <span class="token number">27</span> Oct <span class="token number">2017</span> 06:35:57 GMT
</code></pre></div><p>随后我们每次请求时，会带上一个叫 <code>If-Modified-Since</code> 的时间戳字段，它的值正是上一次 response 返回给它的 <code>Last-modified</code> 值：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>If-Modified-Since: Fri, <span class="token number">27</span> Oct <span class="token number">2017</span> 06:35:57 GMT
</code></pre></div><p>服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，并在 Response Headers 中添加新的 <code>Last-Modified</code> 值；否则，Response Headers 不会再添加 <code>Last-Modified</code> 字段。</p> <p><strong>注意</strong>：如果响应头中有 <code>Last-modified</code> 而没有 <code>Expire</code> 或 <code>Cache-Control</code> 时，浏览器会有自己的算法来推算出一个时间缓存该文件多久，不同浏览器得出的时间不一样。</p> <p>还是前面的例子，index.html 和 style.css、logo 图片。为了说明 Last—Modified 的操作，这里的 server.js 使用原生的 node 实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ...</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ifModifiedSince <span class="token operator">=</span> request<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">&quot;if-modified-since&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  fs<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">exists</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>exists<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> content</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> raw <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 获取实际文件的修改时间，进行对比</span>
          <span class="token keyword">const</span> stat <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">statSync</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">const</span> lastModified <span class="token operator">=</span> stat<span class="token punctuation">.</span>mtime<span class="token punctuation">.</span><span class="token function">toUTCString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 写响应头 Last-Modified</span>
          response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Last-Modified&quot;</span><span class="token punctuation">,</span> lastModified<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 进行时间对比</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>ifModifiedSince <span class="token operator">&amp;&amp;</span> lastModified <span class="token operator">===</span> ifModifiedSince<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">304</span><span class="token punctuation">,</span> <span class="token string">&quot;Not Modified&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 正常写文件</span>
            response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
              <span class="token string">&quot;Content-Type&quot;</span><span class="token punctuation">:</span> mime<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span>extname<span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            raw<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
</code></pre></div><ol><li><p>服务器只设置协商缓存 Last-Modified。访问页面后，进行 F5 刷新页面访问。
<img src="/Web-Performance-Optimization/assets/img/2020-10-21-00-35-35.5e271cfe.png" alt=""></p> <p>可以看到 index.html 响应代码为 304，而其样式和图片资源则直接通过 memory cache 中获取。</p> <p>查看 Node 日志，只看到 index 资源的请求发给服务器：</p> <ul><li>request url: /</li></ul> <p>为什么是这样子的呢？这是因为 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt;</code> 和<code>&lt;img src=&quot;./logo.png&quot; alt=&quot;&quot; /&gt;</code> 的请求路径均没有变化，Chrome 处理都不会发出请求。这里大家可以想想，假如只有样式变化了，那么不就更新不了文件吗？这个问题后面解答。）</p></li> <li><p>然后更改 index.html 文件部分内容，重新访问页面，可以发现 index.html 响应状态码为 200，这是因为文件最后修改的时间改变了，协商缓存经过验证文件更新了，因此从服务器中获取。
<img src="/Web-Performance-Optimization/assets/img/2020-10-21-00-39-33.3d0dccca.png" alt=""></p></li></ol> <p><strong>完整测试例子</strong>：<a href="https://github.com/Jecyu/Web-Performance-Optimization/tree/master/examples/cache/http/demo04/server.js" target="_blank" rel="noopener noreferrer">cache/http/demo04<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="etag-if-modified-since"><a href="#etag-if-modified-since" class="header-anchor">#</a> Etag/If-Modified-Since</h3> <p>使用 <code>Last-Modified</code> 会存在一些弊端，这其中最常见的就有两个场景：</p> <ul><li>当我们编辑了文件，但文件的内容没有变。<u>服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。</u>因此在这个资源在再次被请求时，会被当作新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。</li> <li>当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 <code>If-Modified-Since</code> 只能检查到以<code>秒</code>为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。</li></ul> <p>这两个场景其实指向了同一个 bug —— <u>服务器并没有正确感知文件的变化。</u>为了解决这样的问题，<code>Etag</code> 作为 <code>Last-Modified</code> 的补充出现了。</p> <p><code>Etag</code> 是由服务器为每个资源生产的唯一的<code>标识字符串</code>，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 <strong>Etag 能够精准地感知文件的变化</strong>。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>ETag: W/<span class="token string">&quot;2237-1566200378000&quot;</span>
</code></pre></div><p>那么下一次请求，请求头里就会带上一个值相同的、名为 <code>if-None-Match</code> 的值供服务端比对：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>If-None-Match: W/<span class="token string">&quot;2237-1566200378000&quot;</span>
</code></pre></div><p><img src="/Web-Performance-Optimization/assets/img/2020-10-14-23-07-11.6b1e0876.png" alt=""></p> <p><u>Etag 的生成过程需要服务器额外开销，</u>会影响服务端的性能，这是它的弊端。Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。<strong>当 Etag 和 Last-Modified 同时存在时，以 Etag 为准</strong>。</p> <p>以前面的例子说明，服务端配置如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;express&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 打印请求地址</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">request url: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>req<span class="token punctuation">.</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>
  express<span class="token punctuation">.</span><span class="token function">static</span><span class="token punctuation">(</span><span class="token string">&quot;public&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    etag<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    lastModified<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    cacheControl<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> listener <span class="token operator">=</span> app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">PORT</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Serving files on http://localhost:&quot;</span> <span class="token operator">+</span> listener<span class="token punctuation">.</span><span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol><li><p>ETag 的测试效果跟 Last-Modified 相似，除了一点，就是无论是 index.html、还是样式和图片资源，再次刷新后都响应了 304。
<img src="/Web-Performance-Optimization/assets/img/2020-10-21-00-52-27.e8c7cacf.png" alt=""></p> <p>查看 Node 日志，可以看到三个资源的请求都发给服务器了：</p> <ul><li>request url: /</li> <li>request url: /style.css</li> <li>request url: /logo.png
chrome 对 ETag 和 Last—Modified 的处理有区别，为了保证设置了协商缓存并起作用的情况下，每个资源向服务器进行验证。因此建议一定要设置 ETag。</li></ul></li> <li><p>这个时候对 css 进行更改，并刷新页面，会获取到最新的资源。
<img src="/Web-Performance-Optimization/assets/img/2020-10-21-00-54-51.14f0002b.png" alt=""></p></li></ol> <p><strong>完整测试例子</strong>：<a href="https://github.com/Jecyu/Web-Performance-Optimization/tree/master/examples/cache/http/demo05/server.js" target="_blank" rel="noopener noreferrer">cache/http/demo05<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="如何废弃和更新缓存的资源"><a href="#如何废弃和更新缓存的资源" class="header-anchor">#</a> 如何废弃和更新缓存的资源</h2> <p>协商缓存可以让浏览器先跟服务器验证，强缓存的作用是为了让浏览器不发送资源请求。如果都不让浏览器发资源请求了，这缓存怎么更新呢？</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-19-16-34-59.a6a63904.png" alt=""></p> <p>如上图，index.html 整个文件都没有更改，但是它引用的 a.css 样式文件更新了，如何让浏览器获取最新的样式资源呢？</p> <p>一种方案是，我们可以通过<strong>更新页面中引用的资源路径</strong>，让浏览器主动放弃缓存，加载新资源。类似这样，每次更改版本号：</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-21-01-51-30.355621f0.png" alt=""></p> <p>下次上线，把链接地址改成新的版本，就更新资源了。但是这样问题解决了么？</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-21-01-52-26.44b706ce.png" alt=""></p> <p>页面引用了 3 个 css，而某次上线只改了其中的 a.css，如果所有链接都更新版本，就会导致 b.css，c.css 也失效。</p> <p>因此，要解决这个问题，<strong>必须让 url 的修改与文件内容关联，摘要信息与文件内容一一对应</strong>，就需要有一种可以精确到单个文件粒度的缓存控制依据。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-21-01-57-22.c7e8980c.png" alt=""></p> <p>此时，再用文件修改，就只更新那个文件对应的 url 即可。而现代企业，为了进一步提升网址性能，会把静态资源和动态网页分集群部署，静态资源会被部署到 CDN 解读上，网页上引用的资源也会变成对应的部署路径。</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-21-01-59-57.671f1187.png" alt=""></p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-21-02-00-09.03eb0be2.png" alt=""></p> <p>这次发布，<strong>同时改了页面结构和样式，也更新了静态资源对应的 url 地址</strong>，现在要发布代码上线，我们是先上线页面，还是先上线静态资源？</p> <p>原版本：</p> <ul><li>index.html</li> <li>a.css?v=1234</li></ul> <ol><li><p><strong>先部署页面，再部署资源</strong>：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。</p> <ul><li>新的页面：index.html</li> <li>加载旧的资源：a.css?v=5678（因为新的资源还没部署）</li></ul></li> <li><p><strong>先部署资源，再部署页面</strong>：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。</p> <ul><li>加载旧的页面：index.html（因为新的资源还没部署）</li> <li>加载新的资源：a.css?v=5678</li></ul></li></ol> <p>单独部署下，同时更新静态资源与动态资源不会有问题。如果是使用 CDN 先后发布资源和页面，则会存在上面的<strong>覆盖式发布</strong>的问题，用待发布资源 覆盖 已发布资源，就有这种问题。解决它的方案，就是实现<strong>非覆盖式发布</strong>。</p> <ul><li>覆盖式发布（用待发布资源覆盖已发布资源）</li> <li>非覆盖式发布（采用 hash）</li></ul> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-21-02-01-13.713012cc.png" alt=""></p> <p>看上图，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，<strong>先全量部署静态资源，再灰度部署页面</strong>，整个问题就比较完美的解决了。</p> <ul><li>a_5678.css 新资源</li> <li>a_1234.css 旧资源</li></ul> <p>这种情况下，则不会出现这个问题，旧版本的页面依然请求了旧的资源，新版本的页面请求新的资源。在生产环境下，如何进行 hash 处理，可以看 <a href="https://github.com/pigcan/blog/issues/9" target="_blank" rel="noopener noreferrer">基于 webpack 的持久化缓存方案<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 这篇文章、<a href="https://webpack.js.org/guides/caching/#output-filenames" target="_blank" rel="noopener noreferrer">webpack 官方文档 Caching<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、以及 Vue CLI 官方文档的设置。</p> <h2 id="项目实战：进行资源更新时，为什么一定要手动清除缓存"><a href="#项目实战：进行资源更新时，为什么一定要手动清除缓存" class="header-anchor">#</a> 项目实战：进行资源更新时，为什么一定要手动清除缓存</h2> <p>项目例子：南宁实施监督一张图项目</p> <h3 id="分析现有的缓存策略，进行资源的更新与验证。"><a href="#分析现有的缓存策略，进行资源的更新与验证。" class="header-anchor">#</a> 分析现有的缓存策略，进行资源的更新与验证。</h3> <h4 id="先回顾浏览器存读缓存完整流程"><a href="#先回顾浏览器存读缓存完整流程" class="header-anchor">#</a> 先回顾浏览器存读缓存完整流程</h4> <p>首次请求：</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-21-02-05-37.c42ff712.png" alt=""></p> <p>再次请求：</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-10-21-02-05-44.3fbca96b.png" alt=""></p> <h4 id="整理现有策略"><a href="#整理现有策略" class="header-anchor">#</a> 整理现有策略</h4> <p><strong>首次访问时</strong>（记得先禁用 「Disable cache」，避免之前的缓存影响）：</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-11-15-21-45-37.8658911f.png" alt=""></p> <p>HTTP 请求头：</p> <ul><li><code>Cache-Control：no-cache</code>（前端编码设置，意味着每次缓存前都需要进行验证，借助 <code>Etag</code> 和 <code>Last-Modified</code>）
<ul><li>index.html</li> <li>css</li> <li>js</li> <li>图片</li></ul></li> <li><code>&quot;Cache-Control&quot;: &quot;no-cache, no-store, must-revalidate&quot;</code>（前端编码设置）
<ul><li>json 文件</li></ul></li></ul> <p>HTTP 响应头：</p> <ul><li>协商缓存（所有文件）
<ul><li>Last-Mdified</li> <li>Etag</li></ul></li></ul> <p><strong>再次访问时</strong>：</p> <ul><li>新建 tag，打开页面访问，几乎所有资源都是从 disk cache 获取，除了 json 文件被设置了不使用缓存（请求头设置）。
<img src="/Web-Performance-Optimization/assets/img/2020-11-15-21-44-56.d576452b.png" alt=""></li> <li>直接刷新访问，请求头携带 <code>Cache-Control: max-age=0</code>，跳过强缓存，使用协商缓存。
<img src="/Web-Performance-Optimization/assets/img/2020-11-15-21-50-50.d164f96a.png" alt="">
首页 index.html 响应为 304，证明协商缓存起作用。</li></ul> <p><strong>更新资源，验证现有策略</strong>：分别更新不同类型的静态文件，包括 html、css、js 以及图片、字体文件等。</p> <ul><li>验证正常的行为，资源更新时，重新访问页面还是旧的资源。</li> <li>验证不正常的行为，资源刷新不会更新。</li></ul> <ol><li>更新 index.html 内容，在 head 标签，添加样式设置</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">html body</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 可以开启或关闭进行反复测试 */</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> 2rem<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div><p>关闭旧的页面：</p> <ul><li>更新资源，重新访问该页面，还是加载旧的 index.html。
<img src="/Web-Performance-Optimization/assets/img/2020-11-15-23-13-04.2194e0ae.png" alt=""></li> <li>然后进行刷新（Cache-Control: max-age=0），则会加载最新的资源。</li></ul> <ol start="2"><li>更新 js、css 文件</li></ol> <p>给 task-manager.vue 组件，添加边框样式：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- ... --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>scss<span class="token punctuation">&quot;</span></span> <span class="token attr-name">scoped</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
<span class="token selector">.manager-container</span> <span class="token punctuation">{</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 1rem orange solid<span class="token punctuation">;</span>
  <span class="token comment">/* padding: 1rem;
  width: 100%;
  height: 100%; */</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>重新打包，主要关注打包后的 hash 文件名是否变化了，index.html 的外链是否也跟着变了。</p> <ul><li>Before ：
<ul><li>task-manager.aeb1966b.js.gz</li> <li>task-manager.aeb1966b.js</li> <li><code>&lt;link href=js/task-manager.aeb1966b.js rel=prefetch&gt;</code></li></ul></li> <li>After:
<ul><li>task-manager.c2553364.js</li> <li>task-manager.c2553364.js.gz</li> <li><code>&lt;link href=js/task-manager.c2553364.js rel=prefetch&gt;</code></li></ul></li></ul> <p>部署到服务器上，再次访问当前页面，出现与更新 index.html 的效果。</p> <h3 id="缓存失效复现解决排查"><a href="#缓存失效复现解决排查" class="header-anchor">#</a> 缓存失效复现解决排查</h3> <h4 id="_1-为什么首次设置的响应头为-no-cache，在-index-html-更新后，再次访问的页面却是旧的？"><a href="#_1-为什么首次设置的响应头为-no-cache，在-index-html-更新后，再次访问的页面却是旧的？" class="header-anchor">#</a> 1. 为什么首次设置的响应头为 no-cache，在 index.html 更新后，再次访问的页面却是旧的？</h4> <p><img src="/Web-Performance-Optimization/assets/img/2020-11-15-22-41-39.9637b178.png" alt=""></p> <p><strong>猜想</strong>：no-cache 在之后的资源请求里，都没有发起验证。</p> <p>可以看到请求头没有携带协商内容需要的信息。因为首次访问时，请求头携带了 no-cache 设置有作用，再次请求时就直接从浏览器缓存中获取，不需要访问服务端，请求头也没有携带。</p> <p>**验证猜想：**经过测试，给前端请求头设置 &quot;Cache-control: no-cache&quot; 是有缺陷的，再次请求时，浏览器并不会去跟服务器验证，但会从缓存中获取。</p> <p><strong>解决方案</strong>：不要在请求头设置<code>Cache-control: no-cache</code>，应该由服务端在响应头中进行设置。</p> <h4 id="_2-更新-css-文件、js-等外链文件"><a href="#_2-更新-css-文件、js-等外链文件" class="header-anchor">#</a> 2. 更新 css 文件、js 等外链文件</h4> <p>因为 index.html 文件被存储了，里面的外链请求的都是旧的文件。因此即使更新了 css、js 资源，而 index.html 请求的还是旧的资源。</p> <p>只需要解决 index.html 这个问题，就可以解决。</p> <p>除了 html、js 等，其他的 json、图片等资源待测试，后续补充到文章里。更多的项目案例问题，大家有遇到的话可以一起研究、探讨。</p> <h3 id="服务器如何进行配置以符合最佳实践原则"><a href="#服务器如何进行配置以符合最佳实践原则" class="header-anchor">#</a> 服务器如何进行配置以符合最佳实践原则</h3> <h4 id="最佳实践"><a href="#最佳实践" class="header-anchor">#</a> 最佳实践</h4> <p>在我们面对一个具体的缓存需求时，到底该怎么决策呢？如何运用好强制缓存和协商缓存武器？</p> <p>让我们现在一起解读一下这张流程图（来源：Chrome 官网）</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-06-17-16-37-10-chrome-cache-guide.098998a1.png" alt=""></p> <p>当我们的资源内容不可复用时，直接为 <code>Cache-Control</code> 设置 <code>no-store</code>，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 <code>Cache-Control</code> 的值为 <code>no-cache</code>；否则考虑该资源是否可以被<code>代理服务器</code>缓存，根据其结果决定为 <code>private</code> 还是 <code>public</code>；然后考虑资源的过期时间，设置对应的 <code>max-age</code> 和 <code>s-maxage</code> 值；最后，配置协商缓存需要用到 <code>Etag</code>、<code>Last-Modified</code> 等参数。</p> <p>给一个资源设置强缓存和协商缓存后，再次请求该资源时，会先判断 max-age 是否过期，如果不过期就从缓存拿，过期后就直接向服务器请求。这个时候会携带 Last-Modified 和 Etag 给服务器对比，如果文件改变了就重新发送，否则就返回 304，让浏览器继续从本地缓存中取。</p> <ol><li>对于不常变化的资源，设置一年的 max-age 过期时间。</li></ol> <p><code>Cache-Control: max-age=31536000</code>，比如请求在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。如果配置中还增加 public 的话，CDN 也可以缓存起来，效果拔群。</p> <ol start="2"><li>对于经常变化的资源，可以设置 no-cache 进行验证：</li></ol> <p><code>Cache-Control: no-cache</code></p> <p>这里的资源不单单指静态资源，也可能是网页资源，例如博客文章。这类资源的特点是：URL 不能变化，但内容可以(且经常)变化。我们可以设置 <code>Cache-Control: no-cache</code> 响应头来迫使浏览器每次请求都必须找服务器验证资源是否有效。</p> <div class="language-js extra-class"><pre class="language-js"><code>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>
  express<span class="token punctuation">.</span><span class="token function">static</span><span class="token punctuation">(</span><span class="token string">&quot;public&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    etag<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    lastModified<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    cacheControl<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">setHeaders</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span> path</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> hashRegExp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">&quot;\\.[0-9a-f]{8}\\.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&quot;.html&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Cache-Control&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;no-cache&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>hashRegExp<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Cache-Control&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;max-age=10&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>既然提到了验证，就必须 ETag 或者 Last-Modified 出场。这些字段都会由专门处理静态资源的常用类库(例如 koa-static、Express)自动添加，无需开发者过多关心。</p> <ol start="3"><li>所有的资源配置，都添加 hash 根据内容去处理。</li></ol> <h4 id="以-tomcat-9-0-设置为例："><a href="#以-tomcat-9-0-设置为例：" class="header-anchor">#</a> 以 Tomcat 9.0 设置为例：</h4> <p>Tomcat 9.0 默认对所有资源都配置了协商缓存。</p> <p>我们可以通过以下配置，对 css、js、image 资源设置强缓存，过期时间为5分钟：</p> <p>而 index.html 还是走的协商缓存，这样的话，只要前端资源打包更新后，用户访问 index.html 都是最新的，如果引用的资源有变化，则会引用最新的资源比如 js，不受缓存影响。</p> <p>如果没有变化，则会重用之前的缓存。</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>ExpiresFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">&gt;</span></span>org.apache.catalina.filters.ExpiresFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>ExpiresByType image<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>access plus 5 minutes<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">&gt;</span></span>
 <span class="token comment">&lt;!-- &lt;init-param&gt;
    &lt;param-name&gt;ExpiresByType html&lt;/param-name&gt;
    &lt;param-value&gt;access plus 0 minutes&lt;/param-value&gt;
 &lt;/init-param&gt; --&gt;</span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>ExpiresByType text/css<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>access plus 5 minutes<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>ExpiresByType application/javascript<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>access plus 5 minutes<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>



  <span class="token comment">&lt;!-- ==================== Built In Filter Mappings ====================== --&gt;</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>ExpiresFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dispatcher</span><span class="token punctuation">&gt;</span></span>REQUEST<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dispatcher</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><img src="/Web-Performance-Optimization/assets/img/2020-11-21-22-30-15.ff56fe31.png" alt=""></p> <p>再次访问，从 dist cache 中获取：</p> <p><img src="/Web-Performance-Optimization/assets/img/2020-11-21-22-31-49.92ab3995.png" alt=""></p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>本文从浏览器缓存的位置（memory cache、disk cache）以及浏览器策略（强缓存、协商缓存）两个方面来说明浏览器的缓存策略，希望看到这里你能够知道 web 应用静态资源什么时候被写入缓存、什么时候进行读取、又如何进行设置失效更新。</p> <p>对于静态资源的优化方案来说：</p> <ul><li>配置超长时间的本地缓存——节省带宽，提高性能。</li> <li>采用内容摘要作为缓存更新依据 —— 精确的缓存控制</li> <li>静态资源 CDN 部署 —— 优化网络请求</li> <li>更新资源发布路径实现非覆盖式发布 —— 平滑升级</li></ul> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li><a href="/Web-Performance-Optimization/reference/#网络">Web 性能优化资源合集（持续更新）</a></li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/Jecyu/Web-Performance-Optimization/edit/master/docs/cache/browser-cache.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">12/7/2020, 11:31:36 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Web-Performance-Optimization/cache/" class="prev router-link-active">介绍</a></span> <span class="next"><a href="/Web-Performance-Optimization/cache/browser-localStorage.html">浏览器之本地存储——Cookie、Web Storage、IndexedDB</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Web-Performance-Optimization/assets/js/app.7cae2d68.js" defer></script><script src="/Web-Performance-Optimization/assets/js/2.72369abb.js" defer></script><script src="/Web-Performance-Optimization/assets/js/4.df7b7976.js" defer></script>
  </body>
</html>
