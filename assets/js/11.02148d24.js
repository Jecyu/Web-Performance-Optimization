(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{220:function(v,a,s){v.exports=s.p+"assets/img/2020-06-15-16-15-08-svg-canvas-02.4aea5ec2.png"},221:function(v,a,s){v.exports=s.p+"assets/img/2020-06-15-15-22-58-svg-canvas.f5122711.png"},222:function(v,a,s){v.exports=s.p+"assets/img/2020-06-16-15-14-09-canvas-svg-01.1b55d1e8.png"},223:function(v,a,s){v.exports=s.p+"assets/img/2020-06-16-16-56-27-svg-performance-01.f2329676.png"},224:function(v,a,s){v.exports=s.p+"assets/img/2020-06-16-16-58-15-canvas-performance-01.c69e8b5a.png"},225:function(v,a,s){v.exports=s.p+"assets/img/2020-06-16-14-56-38-map-render.f1f0c0d5.png"},226:function(v,a,s){v.exports=s.p+"assets/img/2020-06-16-14-57-41-map-render-02.74c503ef.png"},227:function(v,a,s){v.exports=s.p+"assets/img/2020-06-16-14-58-07-map-03.6c3b7d88.png"},228:function(v,a,s){v.exports=s.p+"assets/img/2020-06-16-15-00-18-map-canvas.c8597073.png"},471:function(v,a,s){"use strict";s.r(a);var _=s(0),t=Object(_.a)({},(function(){var v=this,a=v.$createElement,_=v._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"图表的性能优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图表的性能优化"}},[v._v("#")]),v._v(" 图表的性能优化")]),v._v(" "),_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),_("p",[v._v("有人听说 SVG 和 Canvas 的同学吗？能够说说他们的区别否？")]),v._v(" "),_("p",[v._v("图表的性能优化也离不开两个方面：渲染速度 + 交互响应。\n策略离不开：懒加载、按需（即局部）")]),v._v(" "),_("p",[v._v("概要：")]),v._v(" "),_("ul",[_("li",[v._v("绘图技术：\n"),_("ul",[_("li",[v._v("SVG")]),v._v(" "),_("li",[v._v("Canvas")]),v._v(" "),_("li",[v._v("WebGL")])])]),v._v(" "),_("li",[v._v("图表库\n"),_("ul",[_("li",[v._v("Echart")]),v._v(" "),_("li",[v._v("G2（AntV 团队）")]),v._v(" "),_("li",[v._v("d3")])])]),v._v(" "),_("li",[v._v("地图引擎\n"),_("ul",[_("li",[v._v("百度地图")]),v._v(" "),_("li",[v._v("Arcgis")]),v._v(" "),_("li",[v._v("OpenLayers")])])])]),v._v(" "),_("h2",{attrs:{id:"基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[v._v("#")]),v._v(" 基础")]),v._v(" "),_("h3",{attrs:{id:"什么是-svg"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-svg"}},[v._v("#")]),v._v(" 什么是 SVG")]),v._v(" "),_("ul",[_("li",[v._v("一种使用 "),_("code",[v._v("XML")]),v._v(" 描述的 2D 图形的语言")]),v._v(" "),_("li",[v._v("SVG 基于 XML 意味着，SVG DOM 中的每个元素都是可用的，可以为某个元素附加 JavaScript 事件处理器。")]),v._v(" "),_("li",[v._v("在 SVG 中，每个被绘制的图形均为视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现。（ "),_("code",[v._v("svgElement.setAttribute(handle.name, handle.value")]),v._v("); // 改变属性）")])]),v._v(" "),_("h3",{attrs:{id:"什么是-canvas"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-canvas"}},[v._v("#")]),v._v(" 什么是 Canvas")]),v._v(" "),_("ul",[_("li",[v._v("Canvas 通过 JavaScript 来绘制 2D 图形。")]),v._v(" "),_("li",[v._v("Canvas 是逐像素进行渲染的。")]),v._v(" "),_("li",[v._v("在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么"),_("code",[v._v("整个场景也需要重新绘制")]),v._v("，包括任何或许已被图形覆盖的对象。")])]),v._v(" "),_("h3",{attrs:{id:"什么是-webgl？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-webgl？"}},[v._v("#")]),v._v(" 什么是 WebGL？")]),v._v(" "),_("p",[v._v("WebGL 既可以绘制 2D 图形，也可以绘制 3D 图形。")]),v._v(" "),_("ul",[_("li",[v._v("基于 Canvas 的 3D 框架")]),v._v(" "),_("li",[v._v("主要用来做 3D 展示、动画、游戏")])]),v._v(" "),_("h2",{attrs:{id:"svg-vs-canvas"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#svg-vs-canvas"}},[v._v("#")]),v._v(" SVG vs Canvas")]),v._v(" "),_("p",[v._v("Canvas 较新，由 Apple 私有的技术发展而来。而 SVG 历史悠久，2003 年成为 W3C 标准。为什么有了 Canvas 后，还要使用 svg\n？")]),v._v(" "),_("p",[v._v("最明显的原因是，因为 svg 是不依赖于终端设备的像素，可以随意缩放大小而不会失真，canvas 则会变模糊。为什么会导致这样的差别呢？因为 SVG 的渲染原理是"),_("u",[v._v("通过对图形的数学描述来绘图的。")]),v._v("例如：以下多啦 A 梦的头型的思路是，我们先画一个贝塞尔函数，然后填充颜色。")]),v._v(" "),_("p",[v._v("而 Canvas 的渲染原理是"),_("u",[v._v("通过对每个像素颜色的填充，最后组成图形。")]),v._v("例如，以下马里奥的帽子我们可以看出，其实帽子的形状是由一个个像素填充出来的。")]),v._v(" "),_("p",[v._v("另外 Canvas 渲染出来的图叫位图，SVG 渲染出来的图叫矢量图。")]),v._v(" "),_("p",[_("img",{attrs:{src:s(220),alt:""}})]),v._v(" "),_("p",[v._v("是不是所有图形都用 SVG 画就好了，位图就淘汰了（目前来说是不可能的，像照相机的出图都是 jpg、png 等位图）。SVG 也有它的缺点。")]),v._v(" "),_("h3",{attrs:{id:"详细对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#详细对比"}},[v._v("#")]),v._v(" 详细对比")]),v._v(" "),_("p",[v._v("Canvas")]),v._v(" "),_("ul",[_("li",[v._v("依赖分辨率")]),v._v(" "),_("li",[v._v("不支持事件处理器")]),v._v(" "),_("li",[v._v("弱的文本渲染能力")]),v._v(" "),_("li",[v._v("能够以 "),_("code",[v._v("·png")]),v._v(" 或 "),_("code",[v._v(".jpg")]),v._v(" 格式保存结果图像")]),v._v(" "),_("li",[v._v("最适合图像密集型的游戏，其中的许多对象会被频繁重绘")])]),v._v(" "),_("p",[v._v("SVG")]),v._v(" "),_("ul",[_("li",[v._v("不依赖分辨率")]),v._v(" "),_("li",[v._v("支持事件处理器")]),v._v(" "),_("li",[v._v("最适合带有大型渲染区域的应用程序（比如谷歌地图）")]),v._v(" "),_("li",[v._v("复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）")]),v._v(" "),_("li",[v._v("不适合游戏应用")])]),v._v(" "),_("p",[v._v("对于开发人员：")]),v._v(" "),_("ul",[_("li",[v._v("对于画在 Canvas 上的部件，你需要处理重绘。而 SVG 则不用，你修改 SVG DOM 则浏览器会自动帮你重绘。")]),v._v(" "),_("li",[v._v("Canvas 不负责帮你侦测鼠标/触摸事件发生在哪一个图形元件上，而 SVG 可以。")])]),v._v(" "),_("p",[v._v("SVG 可以理解为一个个的图形放到页面上，而 Canvas 则是使用画笔一个个的绘制图形。")]),v._v(" "),_("h3",{attrs:{id:"性能对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能对比"}},[v._v("#")]),v._v(" 性能对比")]),v._v(" "),_("p",[v._v("性能对比要看场景。从底层来看，Canvas 的性能受画布尺寸影响更大，而 SVG 的性能受图形元素影响更大。下图是微软 MSDN 上给的一个对比图：")]),v._v(" "),_("p",[_("img",{attrs:{src:s(221),alt:""}})]),v._v(" "),_("p",[v._v("比较流行的看法是 SVG 做定制和交互更有优势，")]),v._v(" "),_("p",[v._v("Canvas 是个像素库，绘制完了基本不用记录过长，更快。svg 建立了一大堆可交互对象，本性长于交互，但性能会弱些。但是可以对 Canvas 封装一层（例如 zRender ），可以让 Canvas 像 svg 一样操作和交互。")]),v._v(" "),_("p",[_("img",{attrs:{src:s(222),alt:""}})]),v._v(" "),_("ul",[_("li",[v._v("移动端优选 SVG\n"),_("ul",[_("li",[v._v("（内存和 CPU，Canvas 占内存多）")])])]),v._v(" "),_("li",[v._v("图表个数很多时优选 SVG")]),v._v(" "),_("li",[v._v("导出小文件高清晰时使用 SVG")]),v._v(" "),_("li",[v._v("部分特殊渲染效果只有 Canvas 支持")]),v._v(" "),_("li",[v._v("数据量特别大时推荐使用 Canvas 渲染")])]),v._v(" "),_("p",[v._v("SVG 必须维护对它呈现的每个对象的引用。您创建的每个 SVG / VML 元素都是 DOM 中的真实元素。默认情况下，这可以让您更好地跟踪您创建的元素，并且默认情况下更容易处理鼠标事件，但是当存在大量对象时，它会显着减慢速度")]),v._v(" "),_("p",[v._v("HTML5 Canvas 只是位图的绘图表面。你设置绘制(用颜色和线条粗细说)，绘制那个东西，然后画布不知道那个东西：它不知道它在哪里或者你刚刚绘制的是什么，它是只是像素。如果你想绘制矩形并让它们四处移动或可选择，那么你必须从头开始编写所有这些代码，包括记住你绘制它们的代码。")]),v._v(" "),_("p",[v._v("关于 javascript：HTML5 Canvas vs. SVG vs. div")]),v._v(" "),_("ul",[_("li",[v._v("https://www.codenong.com/5882716/")])]),v._v(" "),_("h5",{attrs:{id:"大数据量渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#大数据量渲染"}},[v._v("#")]),v._v(" 大数据量渲染")]),v._v(" "),_("p",[v._v("首次渲染时，canvas 比 svg 渲染速度更快")]),v._v(" "),_("p",[v._v("同样渲染 10 万个圆，在 cpu 为 4x （模拟移动端）的情况下，svg 需要 15 秒，而 canvas 只需 5 秒多。")]),v._v(" "),_("p",[v._v("SVG")]),v._v(" "),_("p",[_("img",{attrs:{src:s(223),alt:""}})]),v._v(" "),_("p",[v._v("Canvas")]),v._v(" "),_("p",[_("img",{attrs:{src:s(224),alt:""}})]),v._v(" "),_("p",[v._v("再次更新")]),v._v(" "),_("p",[v._v("对于 SVG 的图形来说，直接修改对应标签的属性即可，有浏览器控制刷新图形。但是对于 Canvas 来说需要清除整个画布，重新绘制所有的图形，也就是说 Canvas 画布上有 10W 个图形，仅仅更新一个图形时，其他 99999 个图形也需要重新绘制。这个性能如何处理的？（TODO）")]),v._v(" "),_("p",[_("a",{attrs:{href:"https://www.html5rocks.com/zh/tutorials/canvas/performance/#toc-perf",target:"_blank",rel:"noopener noreferrer"}},[v._v("提高 HTML5 画布性能"),_("OutboundLink")],1)]),v._v(" "),_("h5",{attrs:{id:"大尺寸渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#大尺寸渲染"}},[v._v("#")]),v._v(" 大尺寸渲染")]),v._v(" "),_("h4",{attrs:{id:"小结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[v._v("#")]),v._v(" 小结")]),v._v(" "),_("p",[v._v("而简单的统计图表性能方面没啥差别，但是在关系分析这种场景下，svg 也就是千这个规模的，canvas 能提高 1-2 个数量级 1W-10W 是可以做到流畅交互的。底层封装了上层使用 svg 还是 canvas 没有差别。")]),v._v(" "),_("h3",{attrs:{id:"为什么-arcgis-4-0-逐步引入-canvas-替代了-svg-显示地图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么-arcgis-4-0-逐步引入-canvas-替代了-svg-显示地图"}},[v._v("#")]),v._v(" 为什么 Arcgis 4.0 逐步引入 Canvas 替代了 SVG 显示地图")]),v._v(" "),_("p",[v._v("地图引擎的核心能力包括：")]),v._v(" "),_("ul",[_("li",[v._v("负责地图图像的展现。")]),v._v(" "),_("li",[v._v("地图上能够叠加点、线、面覆盖物以及其他图层。")]),v._v(" "),_("li",[v._v("地图可以支持拖拽移动、放大缩小操作、叠加元素支持点击的交互。")])]),v._v(" "),_("p",[v._v("这里是参考百度地图技术的演变"),_("a",{attrs:{href:"https://mp.weixin.qq.com/s/U8wGi85BavBxFa8DcxAurw",target:"_blank",rel:"noopener noreferrer"}},[v._v("web 地图引擎的技术演进"),_("OutboundLink")],1),v._v("，Arcgis 的情况跟它很类似。")]),v._v(" "),_("h4",{attrs:{id:"web-引擎-1-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#web-引擎-1-0"}},[v._v("#")]),v._v(" web 引擎 1.0")]),v._v(" "),_("p",[v._v("地图图像的实现")]),v._v(" "),_("p",[v._v("地图初始化确定了"),_("code",[v._v("中心点")]),v._v("和"),_("code",[v._v("级别")]),v._v("，根据这两个信息就能计算出当前视野需要哪些网络，具体过程如下：")]),v._v(" "),_("p",[_("img",{attrs:{src:s(225),alt:""}})]),v._v(" "),_("p",[v._v("覆盖物的实现")]),v._v(" "),_("p",[_("img",{attrs:{src:s(226),alt:""}})]),v._v(" "),_("p",[v._v("图层与覆盖物容器")]),v._v(" "),_("p",[_("img",{attrs:{src:s(227),alt:""}})]),v._v(" "),_("p",[v._v("性能优化")]),v._v(" "),_("ul",[_("li",[v._v("对点抽稀")]),v._v(" "),_("li",[v._v("线剪")])]),v._v(" "),_("p",[v._v("SVG 的渲染成本比较高，由于是 DOM 方式实现，添加大量覆盖物时，性能比较差。")]),v._v(" "),_("h4",{attrs:{id:"web-引擎-2-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#web-引擎-2-0"}},[v._v("#")]),v._v(" Web 引擎 2.0")]),v._v(" "),_("p",[v._v("相比图片"),_("code",[v._v("矢量数据")]),v._v("要小得多，且与屏幕像素密度无关，这能大大降低网络加载的耗时，同时数据在前端绘制的耗时也可接受，总体加载耗时要比图片的方案小很多。")]),v._v(" "),_("p",[_("img",{attrs:{src:s(228),alt:""}})]),v._v(" "),_("h4",{attrs:{id:"web-引擎-3-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#web-引擎-3-0"}},[v._v("#")]),v._v(" Web 引擎 3.0")]),v._v(" "),_("p",[v._v("使用 WebGL 实现二三维效果，webGL 的渲染是在 GPU 中进行，可以显著的提升渲染效率。canvas 呢？")]),v._v(" "),_("h2",{attrs:{id:"webgl-性能优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#webgl-性能优化"}},[v._v("#")]),v._v(" WebGL 性能优化")]),v._v(" "),_("ul",[_("li",[v._v("顶点相关的优化")]),v._v(" "),_("li",[v._v("CPU 优化")]),v._v(" "),_("li",[v._v("像素优化")])]),v._v(" "),_("h2",{attrs:{id:"图表库的选择与性能对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图表库的选择与性能对比"}},[v._v("#")]),v._v(" 图表库的选择与性能对比")]),v._v(" "),_("h2",{attrs:{id:"截图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#截图"}},[v._v("#")]),v._v(" 截图")]),v._v(" "),_("ol",[_("li",[v._v("打印预览功能问题由于要求和前端预览和打印结果一模一样，现在改用前端合成图片，又由于计算服务打印慢和不稳定，上周把出图这块也改成了前端出图，\n高版本的浏览器没有问题，但是在低版本的浏览器会出图慢，和瓦片丢失的问题，和精度有稍微低点问题，和实施沟通后，计划图片合成还是由前端合成，图片\n导图有计算导出，这样在低版本浏览器里面就剩慢的问题。这次去厦门出差他们也提到了打印慢的问题，如果客户要求精度没有那么高的话，打印预览那个功能可以完全采用前端出图实现，解决慢的问题。")]),v._v(" "),_("li",[v._v("htm2Canvas 导出图片时会有跨域的问题，研究可以设置一个参数解决跨域")])]),v._v(" "),_("p",[v._v("上周专门研究了一下前端出图技术，出了用的最多的 html2Canvas 外，还有 dom-to-image.js 和 rasterizeHTML.js，和 puppetee 其他三个前端库，但是在使用在 dojo 里面都没有 html2Canvas 效果好，知乎 app 的截图功能就是 rasterizeHTML.js 实现的\n相关地址：\nhttps://github.com/GoogleChrome/puppeteer\nhttps://github.com/cburgmer/rasterizeHTML.js\nhttps://github.com/tsayen/dom-to-image\nhttps://github.com/niklasvh/html2canvas/")]),v._v(" "),_("p",[v._v("关于产品专题制图出图过慢的性能问题")]),v._v(" "),_("p",[v._v("症状如图：")]),v._v(" "),_("p",[v._v("可以看到上图中，在截图过程中发起了 oms.html 的请求，这个是在 appConfig.json 里面配置的。")]),v._v(" "),_("p",[v._v("原因分析：")]),v._v(" "),_("p",[v._v("在专题制图的导致 html2Canvas 的时候，它内部会拷贝当前目标节点所在的 Document 节点， 这个 document 包含了当前的 iframe，然后把这个 document 进行重新渲染获取样式保证与截图的一致。因此渲染的过程中，会加载当前的地址，从而影响截图的效率。这样发起了对该共享的网站的请求，如果该地址本身跑不通，就会阻塞地图的截屏过过程。\n解决方案：这个跨域地址的设置是产品开发共享 cookie 所需设置。如果项目上根本不需要这个东西，就把 crossdomain 置空即可：")]),v._v(" "),_("p",[v._v("最后，源码仓库：https://github.com/niklasvh/html2canvas ，参考阅读：https://zhuanlan.zhihu.com/p/128935733")]),v._v(" "),_("p",[_("a",{attrs:{href:"https://www.open-open.com/solution/view/1319458447249",target:"_blank",rel:"noopener noreferrer"}},[v._v("iframe异步加载技术及性能"),_("OutboundLink")],1),v._v(" 避免性能问题。\n"),_("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/128935733",target:"_blank",rel:"noopener noreferrer"}},[v._v("浏览器端网页截图方案详解"),_("OutboundLink")],1)]),v._v(" "),_("h3",{attrs:{id:"html-性能问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#html-性能问题"}},[v._v("#")]),v._v(" html 性能问题")]),v._v(" "),_("h2",{attrs:{id:"小结-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#小结-2"}},[v._v("#")]),v._v(" 小结")]),v._v(" "),_("ul",[_("li")])])}),[],!1,null,null,null);a.default=t.exports}}]);