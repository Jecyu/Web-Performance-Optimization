(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{216:function(t,v,_){t.exports=_.p+"assets/img/2020-10-18-22-22-29.4d541f89.png"},217:function(t,v,_){t.exports=_.p+"assets/img/overview.5c784ed4.png"},457:function(t,v,_){"use strict";_.r(v);var s=_(0),e=Object(s.a)({},(function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),s("p",[t._v("在 HTTP 请求流程中，为什么很多站点第二次打开速度会很快？平时清除缓存，到底清除了哪些东西？包括 DNS 吗？为什么服务器部署资源的 hash 值更改了，刷新前端页面还是读取旧的资源，而不是最新服务器上的资源呢？为什么一定要手动清除缓存，才能使更改生效？")]),t._v(" "),s("p",[t._v("如果有人问你，你能够自信地回答上面的问题吗？如果不能，或许你可以通过阅缓存篇找到答案。")]),t._v(" "),s("p",[t._v("一般来说，在客户端发起资源请求时，一个资源可能会经过以下步骤：\n资源生成器 -> 存储数据库（数据库缓存） -> 服务器处理（服务器缓存） -> 客户端缓存（内存或磁盘），最终渲染展示给用户。")]),t._v(" "),s("p",[t._v("当客户端再次发起相同资源的请求时，这个时候为了提升客户端的响应速度，节省用户的带宽，获取的资源很可能是从"),s("strong",[t._v("缓存中")]),t._v("获取，至于缓存是从数据库还是服务器、内存、磁盘就看具体情况。")]),t._v(" "),s("p",[t._v("总的来说，Web 缓存的类型包括以下四种：")]),t._v(" "),s("ul",[s("li",[t._v("数据库数据缓存")]),t._v(" "),s("li",[t._v("服务端缓存\n"),s("ul",[s("li",[t._v("代理服务器缓存")]),t._v(" "),s("li",[t._v("CDN 缓存")])])]),t._v(" "),s("li",[t._v("浏览器端缓存")]),t._v(" "),s("li",[t._v("Web 应用层面运行时缓存\n"),s("ul",[s("li",[t._v("运行时缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据、页面、图片等资源的缓存，根据实际情况将数据存在内存中，从而减少数据库查询次数、加快读写速度和提高响应效率。")])])])]),t._v(" "),s("p",[s("img",{attrs:{src:_(216),alt:""}})]),t._v(" "),s("p",[t._v("上图为（私有）浏览器缓存和（共享）代理缓存。作为前端开发者，我们主要关注"),s("strong",[t._v("浏览器缓存")]),t._v("以及 "),s("strong",[t._v("Web 应用运行时的缓存")]),t._v("。")]),t._v(" "),s("p",[s("img",{attrs:{src:_(217),alt:""}})]),t._v(" "),s("p",[t._v("Chrome 官方的解释：")]),t._v(" "),s("blockquote",[s("p",[t._v("通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。")])])])}),[],!1,null,null,null);v.default=e.exports}}]);